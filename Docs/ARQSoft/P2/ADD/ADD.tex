% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode 
\documentclass[a4paper,11pt,openright,BCOR=15mm,footheight=50pt]{scrbook}

\usepackage[onehalfspacing]{setspace}    
\usepackage[utf8]{inputenc}
\usepackage[portuguese,english]{babel}
\usepackage[square,numbers]{natbib}
\usepackage{graphicx}
\usepackage[pdftex]{hyperref}
\usepackage[T1]{fontenc}
\usepackage{pdfpages}
\usepackage{lettrine}
\usepackage{booktabs}
\usepackage{scrhack}
\usepackage{scrlayer-scrpage}
\usepackage{ulem}
\usepackage{amssymb}

\usepackage[table]{xcolor}
\definecolor{cinza1}{RGB}{200,200,200}
\definecolor{cinza2}{RGB}{70,70,70}
\definecolor{primarycolor}{RGB}{0,102,204}
\definecolor{secondarycolor}{RGB}{102,102,102}

\usepackage{tabularx}
\usepackage{vhistory}
\newcommand\ChapterFont{}
\newcommand\SectionFont{}
\pagestyle{scrheadings}
\ifoot[]{\raisebox{-32pt}{\includegraphics[width=0.15\textwidth]{../logos/logoisep}}}
\ofoot[]{\raisebox{-22pt}{\includegraphics[width=0.10\textwidth]{../logos/logo_DEI_big_transparente}}}
\cfoot[\pagemark]{\pagemark}
\automark[section]{chapter}
\usepackage{blindtext}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{float}

\usepackage[mono=false]{libertine}

\begin{document}

    \selectlanguage{english}
    \frontmatter

    \titlehead{\includegraphics[scale=0.2]{../Logos/logoisep}
    \hfill \includegraphics[scale=0.115]{../Logos/logo_DEI_big_transparente}
    }
	
    \title{\textbf{Attribute-Driven Design (ADD)\\Reengenharia do Sistema LMS}}

    \subtitle{ARQSOFT}

    \author{Master in Informatics Engineering - 2025/2026}

    \publishers
    {
        Luís Manuel Nazário Mendes Santos\\    \texttt{Version 1.0, \today}\\
    }

    \date{Porto, \today}

    \maketitle

    \tableofcontents
    \cleardoublepage

    \mainmatter

% ===========================
% 1. INTRODUÇÃO
% ===========================
\chapter{Introdução}

\section{Contexto do Projeto}

O sistema LMS (Library Management System) foi desenvolvido numa arquitetura monolítica. Esta arquitetura apresenta limitações em performance, disponibilidade, escalabilidade, elasticidade e manutenibilidade.

\section{Objetivo}

Reengenhar o sistema LMS para uma \textbf{arquitetura distribuída baseada em microserviços}, utilizando o método \textbf{ADD (Attribute-Driven Design)} para garantir que os atributos de qualidade sejam alcançados sistematicamente.

\subsection{Estratégia de Migração}

A reengenharia seguirá \textbf{migração progressiva} via padrão \textbf{Strangler Fig}: o novo sistema "estrangula" gradualmente o antigo, permitindo migração incremental, coexistência temporária, redução de risco e validação contínua.

\section{Requisito Funcional Atribuído - Luis Santos (1250534)}

\textbf{FR-1:} Como bibliotecário, quero criar Book, Author e Genre no mesmo processo.

\textbf{Desafio:} Garantir atomicidade numa arquitetura distribuída onde cada entidade está num microserviço diferente com base de dados própria (não podemos usar transações ACID tradicionais).

% ===========================
% 2. ANÁLISE DE REQUISITOS
% ===========================
\chapter{Análise de Requisitos}

\section{Requisitos Funcionais}

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{primarycolor!20}
\textbf{ID} & \textbf{Descrição} \\
\hline
FR-1 & Criar Book, Author e Genre no mesmo processo \\
\hline
FR-2 & Criar Reader e User no mesmo pedido \\
\hline
FR-3 & Devolver livro com comentário e avaliação \\
\hline
\end{tabularx}
\caption{Requisitos Funcionais}
\end{table}

\section{Requisitos Não-Funcionais}

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
\rowcolor{primarycolor!20}
\textbf{ID} & \textbf{Atributo} & \textbf{Requisito} \\
\hline
NFR-1 & Disponibilidade & Melhorar disponibilidade do sistema \\
\hline
NFR-2 & Performance & Aumentar 25\% sob alta demanda \\
\hline
NFR-3 & Escalabilidade & Uso parcimonioso de hardware; escalar sob demanda \\
\hline
NFR-4 & Compatibilidade & Mudanças na API não afetam clientes \\
\hline
NFR-5 & Interoperabilidade & Aderir à estratégia SOA (API-led connectivity) \\
\hline
NFR-6 & Manutenibilidade & Evolução independente de componentes \\
\hline
\end{tabularx}
\caption{Atributos de Qualidade}
\end{table}

\section{Cenários de Qualidade}

Os requisitos não-funcionais foram convertidos em cenários mensuráveis segundo a metodologia ADD.

\subsection{QA-1: Disponibilidade}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Elemento} & \textbf{Descrição} \\
\hline
Estímulo & Falha de instância durante operação \\
\hline
Resposta & Sistema continua operacional via failover \\
\hline
Medida & 99.9\% uptime; recuperação < 30s \\
\hline
\end{tabularx}
\caption{Cenário: Disponibilidade}
\end{table}

\subsection{QA-2: Performance}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Elemento} & \textbf{Descrição} \\
\hline
Estímulo & Alta demanda concorrente \\
\hline
Resposta & Sistema processa carga com melhor tempo resposta \\
\hline
Medida & 25\% melhoria; <200ms P95 \\
\hline
\end{tabularx}
\caption{Cenário: Performance}
\end{table}

\subsection{QA-6: Consistência (FR-1)}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Elemento} & \textbf{Descrição} \\
\hline
Estímulo & Criar Book, Author, Genre numa transação \\
\hline
Resposta & Todas criadas OU nenhuma (atomicidade) \\
\hline
Medida & 100\% consistência; rollback em falha; <3s \\
\hline
\end{tabularx}
\caption{Cenário: Consistência de Dados}
\end{table}

% ===========================
% 3. PADRÕES DE MICROSERVIÇOS
% ===========================
\chapter{Padrões de Microserviços}

\section{Strangler Fig Pattern}

\textbf{Descrição:} Migração incremental criando nova aplicação ao redor da antiga, substituindo gradualmente funcionalidades (como uma figueira-estranguladora envolve uma árvore).

\textbf{Justificação:} Redução de risco (rollback granular), business continuity (sistema sempre operacional), validação incremental e priorização por funcionalidade.

\textbf{Aplicação:} 
\begin{enumerate}
    \item Genre Service (primeiro: mais simples, menor risco)
    \item Author Service
    \item Book Service + Saga (mais complexo: FR-1)
    \item Reader/Lending/Review Services
\end{enumerate}

API Gateway com routing baseado em feature flags e traffic shifting progressivo (10\% → 50\% → 100\%).

\section{Database-per-Service}

\textbf{Descrição:} Cada microserviço possui base de dados própria (não partilhada).

\textbf{Justificação:} Loose coupling (serviços independentes), scaling independente, technology flexibility (escolher tech adequada) e failure isolation (falha numa BD não afeta outras). Estes benefícios superam a complexidade de transações distribuídas.

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|l|l|X|}
\hline
\rowcolor{primarycolor!20}
\textbf{Service} & \textbf{Database} & \textbf{Justificação} \\
\hline
Book Service & PostgreSQL & Dados relacionais; ACID \\
\hline
Author Service & PostgreSQL & Normalized schema \\
\hline
Genre Service & PostgreSQL & Relational queries \\
\hline
Review Service & MongoDB & Document-based; schema flexível \\
\hline
Lending Service & PostgreSQL & Transactional; audit trail \\
\hline
\end{tabularx}
\caption{Database Allocation}
\end{table}

\section{Polyglot Persistence}

\textbf{Conceito:} Usar diferentes tecnologias de armazenamento conforme necessidades específicas (ao invés de "one size fits all").

\textbf{PostgreSQL:} Book/Author/Genre/Lending (relacional, ACID, queries complexas)

\textbf{MongoDB:} Reviews (document-oriented, schema flexível para media/comments variáveis)

\textbf{Redis:} Caching (in-memory, TTL support, alta performance)

\section{Saga Pattern}

\textbf{Descrição:} Gerir transações distribuídas via sequência de transações locais. Se uma falha, executam-se compensating actions (desfazer operações anteriores).

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Abordagem} & \textbf{Vantagens} & \textbf{Desvantagens} \\
\hline
Two-Phase Commit & Consistência forte & Bloqueante; má performance \\
\hline
Saga Choreography & Baixo acoplamento & Debug complexo; sem controlo central \\
\hline
\rowcolor{green!10}
\textbf{Saga Orchestration} & \textbf{Workflow claro; controlo central} & \textbf{Orquestrador é ponto crítico} \\
\hline
\end{tabularx}
\caption{Comparação Transações Distribuídas}
\end{table}

\textbf{Decisão:} Saga Orchestration. Orquestrador central gere workflow, facilitando debug e garantindo ordem de execução. Ponto crítico mitigado via HA (High Availability).

\textbf{Workflow FR-1:} 
\begin{enumerate}
    \item Librarian Process API recebe pedido
    \item Orquestra sequencialmente: Criar Genre → Criar Author → Criar Book
    \item Se Genre falha: aborta imediatamente
    \item Se Author falha: DeleteGenre (compensação)
    \item Se Book falha: DeleteAuthor + DeleteGenre (compensações)
    \item Se tudo sucede: commit implícito
\end{enumerate}

\section{Outbox Pattern}

\textbf{Problema:} Atualizar BD + publicar event não é atômico. Pode resultar em BD atualizada mas event não publicado (inconsistência).

\textbf{Solução:} Single transaction atualiza entity + insere event em outbox table (ambos na mesma BD, logo atômico). Background process lê outbox e publica para RabbitMQ, marcando como published.

\textbf{Benefício:} Garante que todo event publicado corresponde a uma mudança real na BD (at-least-once delivery).

\textbf{Aplicação:} Book, Author e Genre Services.

\section{Domain Events}

\textbf{Conceito:} Eventos representam mudanças significativas no domínio (ex: "BookCreated"). Permitem comunicação assíncrona entre bounded contexts sem acoplamento direto.

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{primarycolor!20}
\textbf{Event} & \textbf{Publisher} \\
\hline
GenreCreated & Genre Service \\
\hline
AuthorCreated & Author Service \\
\hline
BookCreated & Book Service \\
\hline
BookReturned & Lending Service \\
\hline
ReviewSubmitted & Review Service \\
\hline
\end{tabularx}
\caption{Domain Events}
\end{table}

\section{CQRS}

\textbf{Descrição:} Command Query Responsibility Segregation - separar operações de escrita (commands) das de leitura (queries).

\textbf{Justificação:} Permite otimizar independentemente. Writes necessitam normalização e ACID; Reads beneficiam de denormalização e caching.

\textbf{Aplicação Book Service:}

\begin{itemize}
    \item \textbf{Write Model:} Normalized relational (PostgreSQL master) - para integridade
    \item \textbf{Read Model:} Denormalized view book+author+genre (PostgreSQL replica + Redis) - para performance
    \item \textbf{Sincronização:} Read Model Projector consome BookCreated events e atualiza read model assincronamente
\end{itemize}

\textbf{Trade-off:} Eventual consistency (read model pode ter lag de ~500ms) vs performance gains significativos.

\section{Message Broker (RabbitMQ)}

\textbf{Justificação RabbitMQ:} Routing flexibility (topic/direct exchanges), built-in DLQ (Dead Letter Queue para mensagens falhadas), message TTL/priority, strong delivery guarantees, mature/stable.

\textbf{Topologia:}

\begin{itemize}
    \item \textbf{lms.events} (Topic): domain.entity.event (ex: catalog.book.created) - para domain events
    \item \textbf{lms.commands} (Direct): service-specific commands - para Saga commands
    \item \textbf{lms.saga} (Direct): saga orchestration messages - para coordenação Saga
\end{itemize}

% ===========================
% 4. PRIORIZAÇÃO
% ===========================
\chapter{Priorização de Requisitos}

Priorização baseada em importância (valor negócio) vs dificuldade (complexidade técnica).

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|X|c|c|c|}
\hline
\rowcolor{primarycolor!20}
\textbf{Requisito} & \textbf{Importância} & \textbf{Dificuldade} & \textbf{Prioridade} \\
\hline
FR-1 (Book creation) & Alta & Alta & \textbf{5} \\
\hline
NFR-2 (Performance) & Alta & Média & \textbf{4} \\
\hline
NFR-3 (Escalabilidade) & Alta & Média & \textbf{4} \\
\hline
NFR-1 (Disponibilidade) & Alta & Média & \textbf{4} \\
\hline
NFR-5 (API-led) & Alta & Baixa & \textbf{3} \\
\hline
NFR-4 (API Stability) & Média & Média & \textbf{3} \\
\hline
NFR-6 (Manutenibilidade) & Média & Baixa & \textbf{2} \\
\hline
\end{tabularx}
\caption{Matriz de Priorização}
\end{table}

% ===========================
% 5. PROCESSO ADD
% ===========================
\chapter{Processo ADD - Iterações}

O ADD segue abordagem iterativa: cada iteração endereça um conjunto de drivers (requisitos prioritários).

\section{Roadmap Geral}

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|c|X|X|}
\hline
\rowcolor{primarycolor!20}
\textbf{Iteração} & \textbf{Objetivo} & \textbf{Padrões} \\
\hline
1 & Arquitetura distribuída & Microservices, Database-per-Service, Strangler Fig \\
\hline
2 & Consistência FR-1 & Saga, Outbox, Domain Events, RabbitMQ \\
\hline
3 & Performance/Escalabilidade & CQRS, Caching, Load Balancing, Auto-scaling \\
\hline
4 & Disponibilidade/Resiliência & Circuit Breaker, Redundancy, Health Monitoring \\
\hline
\end{tabularx}
\caption{Plano de Iterações}
\end{table}

\section{Iteração 1: Fundação}

\textbf{Drivers:} NFR-5 (API-led), NFR-6 (Manutenibilidade), migração progressiva.

\textbf{Objetivo:} Estrutura geral com microserviços, Database-per-Service e Strangler Fig.

\textbf{Bounded Contexts Identificados:}
\begin{itemize}
    \item Catalog Management: Books, Authors, Genres
    \item User Management: Users, Readers, Librarians
    \item Lending Management: Lendings, Returns
    \item Review Management: Reviews, Ratings
\end{itemize}

\textbf{Microserviços:} Genre, Author, Book, Reader, User, Lending, Review Services.

\textbf{API Layers:} 
\begin{itemize}
    \item Experience API (BFF) - interface com clientes
    \item Process API (Saga Orchestrator) - workflows complexos
    \item System API (Microservices) - operações core
\end{itemize}

\textbf{Infraestrutura:} API Gateway, Service Registry (Eureka), RabbitMQ, PostgreSQL, MongoDB, Redis.

\begin{figure}[H]
\centering
\small
\begin{BVerbatim}
                 +-----------------+
                 |    Monolito     |
                 |  LMS (Legacy)   |
                 +--------+--------+
                          |
                 +--------v--------+
                 |   API Gateway   |
                 | (Routing Logic) |
                 +--------+--------+
                          |
        +-----------------+-----------------+
        |                 |                 |
   +----v----+       +----v----+       +----v----+
   | Genre   |       | Author  |       | Book    |
   | Service |       | Service |       | Service |
   +---------+       +---------+       +---------+
   |Genre DB |       |Author DB|       |Book DB  |
   |PostgreSQL       |PostgreSQL       |PostgreSQL
   +---------+       +---------+       |+Replica |
                                       +---------+
\end{BVerbatim}
\caption{Arquitetura com Strangler Fig}
\end{figure}

\textbf{Alcançado:} Arquitetura distribuída, Database-per-Service, Polyglot Persistence, Strangler Fig, API-led connectivity.

\section{Iteração 2: Consistência e Events}

\textbf{Drivers:} FR-1 (atomicidade), QA-6 (consistência).

\textbf{Objetivo:} Saga Pattern, Domain Events via RabbitMQ, Outbox Pattern para garantir consistência eventual.

\textbf{Padrões Selecionados:} Saga Orchestration, Outbox, Domain Events, RabbitMQ.

\textbf{Workflow FR-1:} Librarian Process API orquestra sequencialmente via RabbitMQ: CreateGenreCommand → GenreCreated (via Outbox) → CreateAuthorCommand → AuthorCreated (via Outbox) → CreateBookCommand → BookCreated (via Outbox) → SagaCompleted. Falhas disparam compensações.

\begin{figure}[H]
\centering
\small
\begin{BVerbatim}
Bibliotecario -> API Gateway -> Librarian Process API
                                      |
                  [CreateGenreCommand via RabbitMQ]
                                      v
                                 Genre Service
                          [Save Genre + Outbox]
                                      |
                           [GenreCreated to RabbitMQ]
                                      v
                              Saga Orchestrator
                                      |
                 [CreateAuthorCommand via RabbitMQ]
                                      v
                                Author Service
                         [Save Author + Outbox]
                                      |
                          [AuthorCreated to RabbitMQ]
                                      v
                              Saga Orchestrator
                                      |
                  [CreateBookCommand via RabbitMQ]
                                      v
                                 Book Service
                          [Save Book + Outbox]
                                      |
                           [BookCreated to RabbitMQ]
                                      v
                              Saga Orchestrator
                                      |
                          [SagaCompletedEvent]
                                      v
                                 Return Success
\end{BVerbatim}
\caption{Saga Orchestration - Happy Path}
\end{figure}

\begin{figure}[H]
\centering
\small
\begin{BVerbatim}
Saga Orchestrator
     |
     +-> Genre Service -> [GenreCreated]
     |
     +-> Author Service -> [AuthorCreated]
     |
     +-> Book Service -> FALHA
     |
     +-> [Compensating Transaction]
     |
     +-> Author Service -> [DeleteAuthorCommand]
     |
     +-> Genre Service -> [DeleteGenreCommand]
     |
     +-> [SagaFailedEvent]
     |
     +-> Return Error
\end{BVerbatim}
\caption{Saga - Compensating Transactions}
\end{figure}

\textbf{Alcançado:} Saga para FR-1, atomicidade via compensations, Outbox, Domain Events via RabbitMQ, eventual consistency.

\section{Iteração 3: Performance e CQRS}

\textbf{Drivers:} NFR-2 (25\% melhoria), NFR-3 (scaling), read-heavy workload.

\textbf{Objetivo:} CQRS, caching multi-camada, otimização reads.

\textbf{Táticas:}

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Tática} & \textbf{Aplicação} \\
\hline
CQRS & Write normalized, Read denormalized \\
\hline
Caching & L1 application cache + L2 Redis (TTL 5min) \\
\hline
Read Replicas & PostgreSQL replicas (50\% cada) \\
\hline
Load Balancing & Kubernetes Service \\
\hline
Database Indexing & Campos pesquisados (title, isbn, authorId) \\
\hline
Async Processing & RabbitMQ non-blocking ops \\
\hline
\end{tabularx}
\caption{Táticas Performance}
\end{table}

\textbf{CQRS Book Service:} Write model (PostgreSQL normalized), Read model (MongoDB denormalized + Redis cache), Read Model Projector consome BookCreated events.

\textbf{Performance Gains:} -40\% query time (denormalization), -60\% cached queries (Redis), +100\% read throughput (replicas), >25\% melhoria P95.

\textbf{Alcançado:} CQRS implementado, caching multi-camada, read replicas, performance otimizada.

\section{Iteração 4: Disponibilidade}

\textbf{Drivers:} NFR-1 (disponibilidade), QA-1 (99.9\% uptime).

\textbf{Objetivo:} Resiliência para 99.9\% availability.

\textbf{Táticas:}

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Tática} & \textbf{Aplicação} \\
\hline
Active Redundancy & 2-10 réplicas por serviço \\
\hline
Health Monitoring & Kubernetes liveness/readiness probes \\
\hline
Circuit Breaker & Resilience4j (threshold 50\%, wait 30s) \\
\hline
Retry + Backoff & Exponential backoff (max 3 tentativas) \\
\hline
Graceful Degradation & Cached data fallback via Redis \\
\hline
Bulkhead & Thread pool isolation por serviço \\
\hline
Timeout & 3s default timeout \\
\hline
\end{tabularx}
\caption{Táticas Disponibilidade}
\end{table}

\textbf{Observability:} Prometheus (métricas RPS/latency/errors), Grafana (dashboards/alerting), ELK (logs centralizados), Jaeger (distributed tracing Saga).

\textbf{Alcançado:} Circuit breakers, retry mechanisms, health monitoring, observability completa.

% ===========================
% 6. ARQUITETURA FINAL
% ===========================
\chapter{Arquitetura Final}

\begin{figure}[H]
\centering
\small
\begin{BVerbatim}
+------------------------------------------------------+
|                   Clientes                           |
+-------------------------+----------------------------+
                          |
+-------------------------v----------------------------+
|          API Gateway                                 |
|   (Auth, Rate Limit, Routing, Circuit Breaker,       |
|    Strangler Fig Routing Logic)                      |
+-------------------------+----------------------------+
                          |
     +--------------------+--------------------+
     |                    |                    |
+----v---------+  +-------v------+  +----------v--------+
|Experience    |  | Process API  |  | System APIs       |
| API (BFF)    |  | (Saga        |  | (Microservices)   |
+--------------|  | Orchestrator)|  +----------+--------+
                  +-------+------+             |
                          |            +-------+--------+
                          |            |                |
                  +-------v-------+ +--v------+  +------v----+
                  |Book Service   | |Author   |  | Genre     |
                  |(CQRS)         | |Service  |  | Service   |
                  |(2-10 pods)    | |(2-5pods)|  | (2-5pods) |
                  +-------+-------+ +---+-----+  +-----+-----+
                          |             |              |
                  +-------+-------+ +---v-----+  +-----v-----+
                  |Book DB(Master)| |Author DB|  |Genre DB   |
                  |PostgreSQL     | |PostgreSQL  |PostgreSQL |
                  +-------+-------+ +---------+  +-----------+
                          |
                  +-------v-------+
                  |Read Replicas  |
                  |(PostgreSQL x2)|
                  +---------------+

   +---------------------------------------------------+
   |   RabbitMQ Message Broker                         |
   |   - lms.events (topic)                            |
   |   - lms.commands (direct)                         |
   |   - lms.saga (direct)                             |
   +---------------------------------------------------+

   +---------------------------------------------------+
   |   Infraestrutura                                  |
   +---------------------------------------------------+
   | * Service Registry (Eureka)                       |
   | * Cache (Redis Cluster)                           |
   | * Monitoring (Prometheus + Grafana)               |
   | * Logging (ELK)                                   |
   | * Tracing (Jaeger)                                |
   | * Orchestration (Kubernetes)                      |
   +---------------------------------------------------+
\end{BVerbatim}
\caption{Arquitetura Final}
\end{figure}

\section{Responsabilidades}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|l|}
\hline
\rowcolor{primarycolor!20}
\textbf{Componente} & \textbf{Responsabilidades} & \textbf{Tecnologia} \\
\hline
API Gateway & Routing, auth, rate limit, circuit breaker, Strangler Fig routing & Spring Cloud Gateway \\
\hline
Librarian Process API & Saga orchestration, compensations & Spring Boot, RabbitMQ \\
\hline
Book Service & CQRS, CRUD, outbox, events & Spring Boot, PostgreSQL, MongoDB \\
\hline
Author/Genre Services & CRUD, outbox, events & Spring Boot, PostgreSQL \\
\hline
Redis & L2 cache, session storage & Redis Cluster \\
\hline
RabbitMQ & Event distribution, commands, saga & RabbitMQ \\
\hline
Kubernetes & Orchestration, auto-scaling, health & Kubernetes, Docker \\
\hline
\end{tabularx}
\caption{Responsabilidades}
\end{table}

\section{Padrões Implementados}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|l|}
\hline
\rowcolor{primarycolor!20}
\textbf{Padrão} & \textbf{Aplicação} & \textbf{Benefício} \\
\hline
Strangler Fig & Migração progressiva & Redução risco \\
\hline
Database-per-Service & BD própria por serviço & Loose coupling \\
\hline
Polyglot Persistence & PostgreSQL + MongoDB + Redis & Otimização por contexto \\
\hline
Saga Orchestration & FR-1 atomicity & Consistência distribuída \\
\hline
Outbox & Atomicidade DB+events & Consistência eventual \\
\hline
Domain Events & Comunicação assíncrona & Decoupling \\
\hline
CQRS & Read/write separation & Performance reads \\
\hline
Message Broker & RabbitMQ async & Event-driven \\
\hline
\end{tabularx}
\caption{Sumário Padrões}
\end{table}

% ===========================
% 7. DECISÕES TÉCNICAS
% ===========================
\chapter{Decisões Técnicas}

\section{TM-1: Migração Progressiva}

\begin{table}[H]
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Issue} & Migrar sem downtime e baixo risco \\
\hline
\textbf{Solução} & Strangler Fig Pattern \\
\hline
\textbf{Detalhes} & API Gateway routing, feature flags, traffic shifting (10\%→100\%) \\
\hline
\textbf{Ordem} & Genre → Author → Book+Saga → Reader/Lending/Review \\
\hline
\textbf{Alternativas} & Big bang (risco), Parallel run (duplicação) - rejeitadas \\
\hline
\end{tabularx}
\caption{TM: Strangler Fig}
\end{table}

\section{TM-2: Transações Distribuídas}

\begin{table}[H]
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Issue} & Consistência Book/Author/Genre em 3 serviços (FR-1) \\
\hline
\textbf{Solução} & Saga Orchestration + Outbox + Domain Events via RabbitMQ \\
\hline
\textbf{Detalhes} & Librarian Process API orquestra, compensating transactions, outbox tables \\
\hline
\textbf{Alternativas} & 2PC (bloqueante), Choreography (debug complexo) - rejeitadas \\
\hline
\end{tabularx}
\caption{TM: Transações}
\end{table}

\section{TM-3: Database Strategy}

\begin{table}[H]
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Issue} & Estruturação de dados \\
\hline
\textbf{Solução} & Database-per-Service + Polyglot Persistence \\
\hline
\textbf{Detalhes} & PostgreSQL (relacional/ACID), MongoDB (document/flexible), Redis (cache) \\
\hline
\textbf{Trade-offs} & Complexidade operacional vs loose coupling e otimização \\
\hline
\end{tabularx}
\caption{TM: Database}
\end{table}

\section{TM-4: CQRS}

\begin{table}[H]
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Issue} & Performance queries em sistema read-heavy \\
\hline
\textbf{Solução} & CQRS no Book Service \\
\hline
\textbf{Detalhes} & Write normalized (PostgreSQL), Read denormalized (MongoDB + Redis) \\
\hline
\textbf{Benefícios} & -40\% query time, +100\% read throughput \\
\hline
\textbf{Trade-off} & Eventual consistency (~500ms lag) vs performance \\
\hline
\end{tabularx}
\caption{TM: CQRS}
\end{table}

\section{TM-5: Message Broker}

\begin{table}[H]
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Issue} & Message broker para event-driven architecture \\
\hline
\textbf{Decisão} & RabbitMQ \\
\hline
\textbf{Justificação} & Routing flexibility, DLQ, TTL/priority, delivery guarantees, mature \\
\hline
\textbf{Topologia} & Topic exchange (events), Direct exchange (commands/saga) \\
\hline
\end{tabularx}
\caption{TM: Message Broker}
\end{table}

\section{TM-6: Outbox}

\begin{table}[H]
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Issue} & Atomicidade DB update + event publishing \\
\hline
\textbf{Solução} & Outbox Pattern \\
\hline
\textbf{Detalhes} & Local transaction atualiza entity + outbox; background publisher → RabbitMQ \\
\hline
\textbf{Benefício} & Eventual consistency garantida, at-least-once delivery \\
\hline
\end{tabularx}
\caption{TM: Outbox}
\end{table}

\section{TM-7: Caching Strategy}

\begin{table}[H]
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{secondarycolor!20}
\textbf{Issue} & Otimização performance reads \\
\hline
\textbf{Solução} & Multi-layer caching com Redis \\
\hline
\textbf{Detalhes} & L1 application cache (local), L2 Redis distributed (TTL 5min) \\
\hline
\textbf{Invalidação} & Cache evict ao receber domain events (BookCreated/Updated) \\
\hline
\textbf{Benefício} & -60\% latency para cached queries \\
\hline
\end{tabularx}
\caption{TM: Caching}
\end{table}

% ===========================
% 8. ROADMAP
% ===========================
\chapter{Roadmap de Implementação}

\section{Estratégia}

Migração progressiva via Strangler Fig, MVP focus, paralelização, serviços managed (Kubernetes, RabbitMQ, Databases), automação CI/CD, patterns desde início.

\section{Fases}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|c|X|}
\hline
\rowcolor{primarycolor!20}
\textbf{Fase} & \textbf{Atividades} \\
\hline
\textbf{1} & 
\textbf{Setup + Genre:} Kubernetes, CI/CD, API Gateway, RabbitMQ, PostgreSQL, Redis. Genre Service (Database-per-service, Outbox, Events). Routing 10\% traffic. \\
\hline
\textbf{2} & 
\textbf{Author/Book + Saga:} Author Service + DB, Book Service + CQRS, Librarian Process API (Saga), compensations, RabbitMQ topology, testes FR-1. Routing 50-100\%. \\
\hline
\textbf{3} & 
\textbf{Performance + Services:} Redis caching (L1+L2), read replicas, Reader/Lending/Review Services, CQRS projectors, load testing, tuning. \\
\hline
\textbf{4} & 
\textbf{Resiliência + Go-Live:} Circuit Breakers, health probes, monitoring (Prometheus/Grafana/ELK/Jaeger), chaos testing, data migration, progressive cutover. \\
\hline
\end{tabularx}
\caption{Fases de Implementação}
\end{table}

\section{Riscos}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\rowcolor{primarycolor!20}
\textbf{Risco} & \textbf{Impacto} & \textbf{Mitigação} \\
\hline
Complexidade Saga + Outbox & Alto & Implementação cedo, testes intensivos \\
\hline
Eventual consistency lag & Médio & Monitoring, alerting, SLAs definidos \\
\hline
RabbitMQ message loss & Alto & Persistent messages, durable queues, manual ack \\
\hline
CQRS sync lag & Médio & Monitoring projector, fallback write model \\
\hline
Performance insuficiente & Alto & Load testing contínuo, caching agressivo \\
\hline
Data migration failures & Alto & Dry-run, validation scripts, rollback plan \\
\hline
Redis cache invalidation & Médio & Event-driven invalidation, TTL safety net \\
\hline
\end{tabularx}
\caption{Análise de Riscos}
\end{table}

% ===========================
% 9. MÉTRICAS
% ===========================
\chapter{Métricas de Sucesso}

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|X|c|c|l|}
\hline
\rowcolor{primarycolor!20}
\textbf{Métrica} & \textbf{Baseline} & \textbf{Target} & \textbf{Medição} \\
\hline
Response Time (P95) & 800ms & <600ms (+25\%) & APM \\
\hline
Availability & 99.5\% & 99.9\% & Uptime monitoring \\
\hline
Throughput & 200 RPS & >250 RPS & Load testing \\
\hline
Scale-up Time & Manual & <2 min & Kubernetes HPA \\
\hline
Deployment Frequency & Semanal & Diária & CI/CD \\
\hline
MTTR & 30 min & <5 min & Incident logs \\
\hline
FR-1 Success Rate & N/A & 99.9\% & Saga logs \\
\hline
FR-1 Execution Time & N/A & <3s (P95) & Tracing \\
\hline
Saga Compensation Rate & N/A & <1\% & Saga failures \\
\hline
CQRS Sync Lag & N/A & <500ms (P95) & Projector metrics \\
\hline
RabbitMQ Message Loss & N/A & 0\% & Message audit \\
\hline
Redis Hit Rate & N/A & >70\% & Redis metrics \\
\hline
\end{tabularx}
\caption{KPIs}
\end{table}

\section{Critérios de Aceitação}

\textbf{Padrões:} Database-per-Service, Polyglot Persistence, Saga, Outbox, Domain Events, Strangler Fig, CQRS, Redis caching.

\textbf{Funcionalidade:} FR-1 implementado, Saga rollback funcional, testes integração 100\%, end-to-end via RabbitMQ.

\textbf{Performance:} CQRS funcional, 250+ RPS, P95 <600ms, auto-scaling 2-10 pods, Redis hit >70\%.

\textbf{Produção:} Circuit breakers, zero downtime deployment, monitoring/logging/tracing operacionais, alerting, documentação completa, 100\% traffic novo sistema.

% ===========================
% 10. VISTAS ARQUITETURAIS
% ===========================
\chapter{Vistas Arquiteturais (4+1 View Model)}

Este capítulo apresenta a arquitetura do sistema LMS segundo o modelo de vistas 4+1 de Philippe Kruchten, que organiza a descrição arquitetural em cinco vistas interligadas: Lógica, Física, Implementação, Processo e Cenários.

\section{Vista Lógica}

A Vista Lógica descreve a estrutura funcional do sistema em termos de componentes, suas responsabilidades e relacionamentos.

\subsection{Nível 1: Contexto do Sistema}

O diagrama de contexto (Nível 1) apresenta o sistema LMS e suas interações com atores externos e sistemas adjacentes.

\textbf{Atores Principais:}
\begin{itemize}
    \item \textbf{Bibliotecário (Librarian):} Gere catálogo (Books, Authors, Genres), empréstimos e estatísticas
    \item \textbf{Leitor (Reader):} Pesquisa livros, requisita empréstimos, devolve com avaliações
    \item \textbf{Administrador (Admin):} Gere utilizadores, configura sistema, monitoriza métricas
\end{itemize}

\textbf{Sistemas Externos:}
\begin{itemize}
    \item Sistema de Autenticação (OAuth 2.0/JWT)
    \item Serviço de Fotos/Media (Storage + CDN)
    \item Sistema de Notificações (Email/SMS)
\end{itemize}

\textit{Diagrama: vista-logica-nivel1.puml}

\subsection{Nível 2: Decomposição em Microserviços}

O Nível 2 decompõe o sistema LMS em microserviços segundo bounded contexts do Domain-Driven Design.

\textbf{System API Layer - Catalog Bounded Context:}
\begin{itemize}
    \item \textbf{Genre Service (Port 8080):} CRUD de géneros, eventos GenreCreated/Updated/Deleted
    \item \textbf{Author Service (Port 8082):} CRUD de autores com CQRS (PostgreSQL write + MongoDB read)
    \item \textbf{Book Command Service (Port 8083):} Operações de escrita (CQRS write side)
    \item \textbf{Book Query Service (Port 8085):} Operações de leitura otimizadas (CQRS read side)
\end{itemize}

\textbf{System API Layer - User Management Bounded Context:}
\begin{itemize}
    \item \textbf{Reader Service (Port 8087):} CRUD de leitores, autenticação JWT
\end{itemize}

\textbf{System API Layer - Lending Bounded Context:}
\begin{itemize}
    \item \textbf{Lending Service (Port 8086):} Requisitar/devolver livros, gerir multas
\end{itemize}

\textbf{Process API Layer:}
\begin{itemize}
    \item \textbf{Saga Orchestrator (Port 8084):} Coordena FR-1 via Saga Pattern, gere compensações
\end{itemize}

\textbf{Comunicação:}
\begin{itemize}
    \item \textbf{Síncrona:} REST APIs via Traefik (routing por path prefix)
    \item \textbf{Assíncrona:} Domain Events via RabbitMQ (topic exchange lms.events)
\end{itemize}

\textit{Diagrama: vista-logica-nivel2.puml}

\subsection{Nível 3: Estrutura Interna de Microserviço}

O Nível 3 detalha a arquitetura interna de um microserviço típico (Book Command Service como exemplo).

\textbf{Camadas (Layered Architecture):}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|}
\hline
\rowcolor{primarycolor!20}
\textbf{Camada} & \textbf{Responsabilidades} \\
\hline
API Layer & Controllers, validation, DTO mapping, exception handling \\
\hline
Service Layer & Business logic, transaction management, event publishing \\
\hline
Domain Layer & Entities, Value Objects, domain rules, optimistic locking \\
\hline
Repository Layer & Data access (JPA), Outbox persistence \\
\hline
Messaging Layer & Event publishing (Outbox Pattern), RabbitMQ configuration \\
\hline
Configuration & Security (JWT), Caching (Redis), cross-cutting concerns \\
\hline
\end{tabularx}
\caption{Camadas Arquiteturais}
\end{table}

\textbf{Fluxo de Request:}
\begin{enumerate}
    \item API Gateway encaminha request
    \item Controller valida e mapeia DTO
    \item Service executa lógica de negócio
    \item Repository persiste Entity + OutboxEvent (mesma transação)
    \item Response devolvido ao cliente
    \item (Assíncrono) OutboxEventPublisher lê PENDING events e publica para RabbitMQ
\end{enumerate}

\textbf{Padrões Implementados:}
\begin{itemize}
    \item Outbox Pattern para consistência eventual
    \item Optimistic Locking (@Version) para concorrência
    \item Value Objects imutáveis (Isbn, Title, Description)
    \item Scheduled polling (1s) do Outbox
    \item At-least-once delivery (retry até 3x, DLQ para falhas)
\end{itemize}

\textit{Diagrama: vista-logica-nivel3.puml}

\section{Vista Física}

A Vista Física descreve o mapeamento dos componentes de software em infraestrutura física (deployment).

\subsection{Nível 2: Deployment com Docker Swarm}

\textbf{Cluster Docker Swarm:}
\begin{itemize}
    \item \textbf{Manager Node:} Executa todos os serviços (desenvolvimento single-node)
    \item \textbf{Overlay Network:} lms\_prod (attachable) para comunicação inter-serviços
    \item \textbf{Volumes:} Persistent storage (postgres\_prod, mongodb\_prod, redis\_prod, rabbitmq\_prod)
\end{itemize}

\textbf{Load Balancer:}
\begin{itemize}
    \item \textbf{Traefik (Port 80, 8090):} Routing baseado em path prefix, health checks, service discovery
\end{itemize}

\textbf{Infrastructure Services (1 replica each):}
\begin{itemize}
    \item PostgreSQL (Port 5432): 5 databases (genre\_db, author\_db, book\_db, lending\_db, reader\_db)
    \item MongoDB (Port 27017): author\_read\_db (CQRS read model)
    \item Redis (Port 6379): L2 cache + Saga state (maxmemory 1GB, LRU eviction)
    \item RabbitMQ (Ports 5672, 15672): Message broker (lms.events exchange)
\end{itemize}

\textbf{Microservices (3 replicas each):}
\begin{itemize}
    \item Cada serviço: CPU limit 0.5, Memory limit 512M
    \item Health checks: /actuator/health (interval 30s, start period 60s)
    \item Rolling updates: parallelism 1, delay 10s, rollback on failure
\end{itemize}

\textbf{High Availability:}
\begin{itemize}
    \item 3 replicas por microserviço (horizontal scaling)
    \item Traefik load balances automaticamente entre replicas saudáveis
    \item Health checks removem instâncias não-saudáveis do balanceamento
    \item Restart policy: on-failure, delay 5s, max 3 attempts
\end{itemize}

\textit{Diagrama: vista-fisica-nivel2.puml}

\section{Vista de Implementação}

A Vista de Implementação descreve a organização do código-fonte, módulos e dependências.

\subsection{Nível 2: Estrutura Multi-Módulo Maven}

\textbf{Root POM (lms-microservices-parent):}
\begin{itemize}
    \item Plugin Management: Checkstyle, JaCoCo, PIT, SonarQube
    \item Quality Gates: Coverage ≥70\%, Mutation ≥60\%, Checkstyle violations = 0
    \item Java 21, Spring Boot, Spring Cloud
\end{itemize}

\textbf{Shared Kernel Module:}
\begin{itemize}
    \item \textbf{DTOs:} Transferência de dados entre serviços (GenreDTO, AuthorDTO, BookDTO, etc.)
    \item \textbf{Domain Events:} Hierarquia polimórfica com @JsonTypeInfo (GenreCreatedEvent, etc.)
    \item \textbf{Messaging:} OutboxEvent, OutboxStatus, EventPublisher (infraestrutura reutilizável)
    \item \textbf{Exceptions:} BusinessException, NotFoundException, ConflictException
    \item \textbf{Base Classes:} BaseEntity, EntityWithVersion, AuditableEntity
\end{itemize}

\textbf{Service Modules (genre-service, author-service, etc.):}

Cada módulo segue estrutura:
\begin{verbatim}
src/main/java/pt/psoft/{service}/
  ├── api/controller/       (REST endpoints)
  ├── services/             (Business logic)
  ├── model/                (Entities, VOs)
  ├── repositories/         (JPA/MongoDB)
  ├── messaging/            (Event pub/sub)
  └── config/               (Security, Cache)
src/main/resources/
  ├── application.yml       (Configuration)
  └── rsa.public.key        (JWT validation)
src/test/java/
  ├── unit/                 (Surefire)
  ├── integration/          (Failsafe)
  └── cdc/                  (Pact contracts)
Dockerfile                  (Multi-stage build)
pom.xml                     (Dependencies)
\end{verbatim}

\textbf{Infrastructure:}
\begin{itemize}
    \item \textbf{docker-compose.yml:} Desenvolvimento local
    \item \textbf{docker-swarm-stack.yml:} Produção com 3 replicas
    \item \textbf{Jenkinsfile-microservices:} CI/CD pipeline (17 stages)
    \item \textbf{init-databases.sql:} Database bootstrapping
\end{itemize}

\textbf{Dependências Maven:}

Todos os service modules dependem de shared-kernel. Saga Orchestrator usa Feign Clients para comunicação síncrona com Genre/Author/Book Services (com @CircuitBreaker e @Retry para resiliência).

\textit{Diagrama: vista-implementacao-nivel2.puml}

\section{Vista de Processo}

A Vista de Processo descreve os aspectos dinâmicos do sistema: concorrência, threads, processos, sincronização.

\subsection{FR-1: Saga Orchestration Process}

\textbf{Workflow Distribuído (Happy Path):}

\begin{enumerate}
    \item Bibliotecário envia POST /api/catalog/books via API Gateway
    \item Saga Orchestrator cria SagaInstance (armazenado em Redis com TTL 1h)
    \item Chama Genre Service (sync REST): CreateGenre → GenreCreated event (via Outbox)
    \item Chama Author Service (sync REST): CreateAuthor → AuthorCreated event (via Outbox)
    \item Chama Book Command Service (sync REST): CreateBook → BookCreated event (via Outbox)
    \item Saga transita para COMPLETED, retorna resposta agregada ao cliente
    \item (Async) Outbox Publishers em cada serviço publicam events para RabbitMQ (1s polling)
    \item Book Query Service consome BookCreated e atualiza read model
\end{enumerate}

\textbf{Compensating Transactions (Failure Path):}

Se Book Command falha:
\begin{enumerate}
    \item Saga transita para COMPENSATING
    \item Executa DeleteAuthor via Author Service REST API
    \item Executa DeleteGenre via Genre Service REST API
    \item Saga transita para COMPENSATED, retorna erro ao cliente
\end{enumerate}

\textbf{Concorrência e Sincronização:}
\begin{itemize}
    \item \textbf{Optimistic Locking:} @Version em todas entities (previne concurrent updates)
    \item \textbf{Saga State:} Armazenado em Redis (single source of truth)
    \item \textbf{Outbox Polling:} Scheduled task @Scheduled(fixedDelay=1000) por serviço
    \item \textbf{Thread Pools:} Bulkhead pattern isola falhas (Resilience4j)
    \item \textbf{Circuit Breaker:} 50\% failure rate threshold, 30s wait
\end{itemize}

\subsection{CQRS Synchronization Process}

\textbf{Author Service (PostgreSQL → MongoDB):}

\begin{enumerate}
    \item Write: AuthorCommandService.createAuthor() persiste em PostgreSQL + Outbox (transação)
    \item Outbox Publisher publica AuthorCreatedEvent para RabbitMQ
    \item AuthorEventConsumer (mesma JVM) consome event
    \item AuthorEventHandler persiste em MongoDB (AuthorReadModel)
    \item @CacheEvict invalida Redis cache
\end{enumerate}

Lag típico: <500ms (eventual consistency aceitável para reads).

\section{Vista de Cenários (+1)}

A Vista de Cenários valida as outras vistas através de casos de uso concretos.

\subsection{Cenário: Criar Book + Author + Genre (FR-1)}

\textbf{Pré-condições:} Bibliotecário autenticado, JWT válido.

\textbf{Fluxo Normal:}
\begin{enumerate}
    \item Bibliotecário submete pedido via UI/Postman
    \item API Gateway valida JWT, encaminha para Saga Orchestrator
    \item Saga cria Genre (se não existe)
    \item Saga cria Author (se não existe)
    \item Saga cria Book com referências a Genre/Author IDs
    \item Retorna BookView agregado (incluindo genre e author details)
    \item Events propagados via RabbitMQ atualizam read models
\end{enumerate}

\textbf{Fluxo Alternativo (Author Service Down):}
\begin{enumerate}
    \item Circuit breaker deteta 50\% falhas após 5 chamadas
    \item Abre circuito, próximas chamadas falham imediatamente (fail-fast)
    \item Saga executa compensação: DeleteGenre
    \item Retorna 503 Service Unavailable ao cliente
    \item Após 30s, circuit breaker tenta half-open (probing)
\end{enumerate}

\textbf{Atributos Validados:}
\begin{itemize}
    \item \textbf{Consistência (QA-6):} Saga garante atomicidade via compensations, 100\% consistência
    \item \textbf{Disponibilidade (QA-1):} Circuit breaker previne cascading failures, graceful degradation
    \item \textbf{Performance (QA-2):} P95 <3s (target), distribuição de carga por 3 replicas
\end{itemize}

% ===========================
% 11. CONCLUSÃO
% ===========================
\chapter{Conclusão}

\section{Objetivos Alcançados}

\begin{itemize}
    \item[$\checkmark$] Strangler Fig: migração progressiva baixo risco
    \item[$\checkmark$] Database-per-Service: loose coupling, independent scaling
    \item[$\checkmark$] Polyglot Persistence: PostgreSQL + MongoDB + Redis otimizado
    \item[$\checkmark$] Saga Pattern: FR-1 atomicidade via compensations
    \item[$\checkmark$] Outbox Pattern: consistência eventual DB+events
    \item[$\checkmark$] Domain Events: comunicação assíncrona RabbitMQ
    \item[$\checkmark$] CQRS: performance reads otimizada
    \item[$\checkmark$] Redis: caching multi-layer alta performance
    \item[$\checkmark$] Performance: 25\%+ melhoria
    \item[$\checkmark$] Disponibilidade: 99.9\%
    \item[$\checkmark$] API-led Connectivity: 3 camadas
\end{itemize}

\section{Padrões Implementados}

\begin{table}[H]
\centering
\small
\begin{tabularx}{\textwidth}{|l|X|c|}
\hline
\rowcolor{primarycolor!20}
\textbf{Padrão} & \textbf{Aplicação} & \textbf{Status} \\
\hline
Strangler Fig & Migração progressiva & $\checkmark$ \\
\hline
Database-per-Service & BD própria por serviço & $\checkmark$ \\
\hline
Polyglot Persistence & PostgreSQL + MongoDB + Redis & $\checkmark$ \\
\hline
Saga & Orchestration FR-1 & $\checkmark$ \\
\hline
Outbox & Atomicidade DB+events & $\checkmark$ \\
\hline
Domain Events & Comunicação assíncrona & $\checkmark$ \\
\hline
CQRS & Book Service read/write & $\checkmark$ \\
\hline
Message Broker & RabbitMQ async & $\checkmark$ \\
\hline
\end{tabularx}
\caption{Checklist Padrões}
\end{table}

\section{Contribuições ADD}

Decisões estruturadas baseadas em drivers, foco em atributos de qualidade, abordagem iterativa, rastreabilidade via technical memos, trade-offs explícitos, priorização clara, visual models (diagramas decomposition/flows/dependencies).

\section{Estratégias Executadas}

Serviços managed, Strangler Fig progressivo, paralelização, MVP focus, patterns desde início, automação CI/CD, Redis multi-layer caching.

\section{Best Practices}

\begin{itemize}
    \item Strangler Fig reduz risco migração
    \item Outbox Pattern critical para consistency
    \item RabbitMQ topology design antecipado
    \item CQRS só onde performance é critical
    \item Redis caching com event-driven invalidation
    \item Monitoring desde início
    \item Integration tests > unit tests em event-driven
    \item Idempotency fundamental para retries
\end{itemize}

Design \textbf{evolutivo} e \textbf{production-ready}, todos padrões microserviços implementados com justificação técnica sólida. Abordagem viável via Strangler Fig, MVP focus, ferramentas managed e Redis high-performance caching.

% ===========================
% REFERÊNCIAS
% ===========================
\begin{thebibliography}{9}

\bibitem{cervantes2016}
Cervantes, H., Kazman, R. (2016). 
\textit{Designing Software Architectures: A Practical Approach}. 
Addison-Wesley.

\bibitem{bass2021}
Bass, L., Clements, P., Kazman, R. (2021). 
\textit{Software Architecture in Practice} (4th ed.). 
Addison-Wesley.

\bibitem{richardson2018}
Richardson, C. (2018). 
\textit{Microservices Patterns}. 
Manning Publications.

\bibitem{newman2015}
Newman, S. (2015).
\textit{Building Microservices: Designing Fine-Grained Systems}.
O'Reilly Media.

\bibitem{fowler2014}
Fowler, M., Lewis, J. (2014).
\textit{Microservices: a definition of this new architectural term}.
\url{https://martinfowler.com/articles/microservices.html}

\bibitem{sei}
SEI - Software Engineering Institute. 
\textit{ADD 3.0 Method}.
\url{https://insights.sei.cmu.edu/library/attribute-driven-design-method-collection/}

\bibitem{hohpe2003}
Hohpe, G., Woolf, B. (2003).
\textit{Enterprise Integration Patterns}.
Addison-Wesley.

\end{thebibliography}

\end{document}